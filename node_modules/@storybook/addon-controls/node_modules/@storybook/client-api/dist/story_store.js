"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.array.sort");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.entries");

require("core-js/modules/es.object.freeze");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.object.values");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.set");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _memoizerific = _interopRequireDefault(require("memoizerific"));

var _tsDedent = _interopRequireDefault(require("ts-dedent"));

var _stable = _interopRequireDefault(require("stable"));

var _lodash = require("lodash");

var _coreEvents = _interopRequireDefault(require("@storybook/core-events"));

var _clientLogger = require("@storybook/client-logger");

var _hooks = require("./hooks");

var _storySort = _interopRequireDefault(require("./storySort"));

var _parameters = require("./parameters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        Story with id ", " already exists in the store!\n\n        Perhaps you added the same story twice, or you have a name collision?\n        Story ids need to be unique -- ensure you aren't using the same names modulo url-sanitization.\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var isStoryDocsOnly = function isStoryDocsOnly(parameters) {
  return parameters && parameters.docsOnly;
};

var includeStory = function includeStory(story) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    includeDocsOnly: false
  };

  if (options.includeDocsOnly) {
    return true;
  }

  return !isStoryDocsOnly(story.parameters);
};

var checkGlobalArgs = function checkGlobalArgs(parameters) {
  var globalArgs = parameters.globalArgs,
      globalArgTypes = parameters.globalArgTypes;

  if (globalArgs || globalArgTypes) {
    _clientLogger.logger.error('Global args/argTypes can only be set globally', JSON.stringify({
      globalArgs: globalArgs,
      globalArgTypes: globalArgTypes
    }));
  }
};

var checkStorySort = function checkStorySort(parameters) {
  var options = parameters.options;
  if (options === null || options === void 0 ? void 0 : options.storySort) _clientLogger.logger.error('The storySort option parameter can only be set globally');
};

var toExtracted = function toExtracted(obj) {
  return Object.entries(obj).reduce(function (acc, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (typeof value === 'function') {
      return acc;
    }

    if (key === 'hooks') {
      return acc;
    }

    if (Array.isArray(value)) {
      return Object.assign(acc, _defineProperty({}, key, value.slice().sort()));
    }

    return Object.assign(acc, _defineProperty({}, key, value));
  }, {});
};

var StoryStore = /*#__PURE__*/function () {
  // Keyed on kind name
  // Keyed on storyId
  function StoryStore(params) {
    var _this = this;

    _classCallCheck(this, StoryStore);

    this._error = void 0;
    this._channel = void 0;
    this._configuring = void 0;
    this._globalArgs = void 0;
    this._globalMetadata = void 0;
    this._kinds = void 0;
    this._stories = void 0;
    this._argTypesEnhancers = void 0;
    this._selection = void 0;

    this.remove = function (id) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$allowUnsafe = _ref3.allowUnsafe,
          allowUnsafe = _ref3$allowUnsafe === void 0 ? false : _ref3$allowUnsafe;

      if (!_this._configuring && !allowUnsafe) throw new Error('Cannot remove a story when not configuring, see https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#story-store-immutable-outside-of-configuration');
      var _stories = _this._stories;
      var story = _stories[id];
      delete _stories[id];
      if (story) story.hooks.clean();
    };

    this.fromId = function (id) {
      try {
        var data = _this._stories[id];

        if (!data || !data.getDecorated) {
          return null;
        }

        return _this.mergeAdditionalDataToStory(data);
      } catch (e) {
        _clientLogger.logger.warn('failed to get story:', _this._stories);

        _clientLogger.logger.error(e);

        return null;
      }
    };

    this.setError = function (err) {
      _this._error = err;
    };

    this.getError = function () {
      return _this._error;
    };

    this.getSelection = function () {
      return _this._selection;
    };

    this.getDataForManager = function () {
      return {
        v: 2,
        globalParameters: _this._globalMetadata.parameters,
        error: _this.getError(),
        kindParameters: (0, _lodash.mapValues)(_this._kinds, function (metadata) {
          return metadata.parameters;
        }),
        stories: _this.extract({
          includeDocsOnly: true,
          normalizeParameters: true
        })
      };
    };

    this.pushToManager = function () {
      if (_this._channel) {
        // send to the parent frame.
        _this._channel.emit(_coreEvents["default"].SET_STORIES, _this.getDataForManager());
      }
    };

    // Assume we are configuring until we hear otherwise
    this._configuring = true;
    this._globalArgs = {};
    this._globalMetadata = {
      parameters: {},
      decorators: []
    };
    this._kinds = {};
    this._stories = {};
    this._argTypesEnhancers = [];
    this._selection = {};
    this._error = undefined;
    this._channel = params.channel;
    this.setupListeners();
  }

  _createClass(StoryStore, [{
    key: "setupListeners",
    value: function setupListeners() {
      var _this2 = this;

      // Channel can be null in StoryShots
      if (!this._channel) return;

      this._channel.on(_coreEvents["default"].SET_CURRENT_STORY, function (_ref4) {
        var storyId = _ref4.storyId,
            viewMode = _ref4.viewMode;
        return _this2.setSelection({
          storyId: storyId,
          viewMode: viewMode
        });
      });

      this._channel.on(_coreEvents["default"].UPDATE_STORY_ARGS, function (id, newArgs) {
        return _this2.updateStoryArgs(id, newArgs);
      });

      this._channel.on(_coreEvents["default"].UPDATE_GLOBAL_ARGS, function (newGlobalArgs) {
        return _this2.updateGlobalArgs(newGlobalArgs);
      });
    }
  }, {
    key: "startConfiguring",
    value: function startConfiguring() {
      this._configuring = true;
    }
  }, {
    key: "finishConfiguring",
    value: function finishConfiguring() {
      this._configuring = false;
      this.pushToManager();
      var _this$_globalMetadata = this._globalMetadata.parameters,
          initialGlobalArgs = _this$_globalMetadata.globalArgs,
          globalArgTypes = _this$_globalMetadata.globalArgTypes;
      var defaultGlobalArgs = globalArgTypes ? Object.entries(globalArgTypes).reduce(function (acc, _ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            arg = _ref6[0],
            defaultValue = _ref6[1].defaultValue;

        if (defaultValue) acc[arg] = defaultValue;
        return acc;
      }, {}) : {}; // To deal with HMR, we consider the previous value of global args, and:
      //   1. Remove any keys that are not in the new parameter
      //   2. Preference any keys that were already set
      //   3. Use any new keys from the new parameter

      this._globalArgs = Object.entries(this._globalArgs || {}).reduce(function (acc, _ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            key = _ref8[0],
            previousValue = _ref8[1];

        if (acc[key]) acc[key] = previousValue;
        return acc;
      }, Object.assign(Object.assign({}, defaultGlobalArgs), initialGlobalArgs));

      if (this._channel) {
        this._channel.emit(_coreEvents["default"].GLOBAL_ARGS_UPDATED, this._globalArgs);
      }
    }
  }, {
    key: "addGlobalMetadata",
    value: function addGlobalMetadata(_ref9) {
      var _this$_globalMetadata2;

      var parameters = _ref9.parameters,
          decorators = _ref9.decorators;

      if (parameters) {
        var args = parameters.args,
            argTypes = parameters.argTypes;
        if (args || argTypes) _clientLogger.logger.warn('Found args/argTypes in global parameters.', JSON.stringify({
          args: args,
          argTypes: argTypes
        }));
      }

      var globalParameters = this._globalMetadata.parameters;
      this._globalMetadata.parameters = (0, _parameters.combineParameters)(globalParameters, parameters);

      (_this$_globalMetadata2 = this._globalMetadata.decorators).push.apply(_this$_globalMetadata2, _toConsumableArray(decorators));
    }
  }, {
    key: "clearGlobalDecorators",
    value: function clearGlobalDecorators() {
      this._globalMetadata.decorators = [];
    }
  }, {
    key: "ensureKind",
    value: function ensureKind(kind) {
      if (!this._kinds[kind]) {
        this._kinds[kind] = {
          order: Object.keys(this._kinds).length,
          parameters: {},
          decorators: []
        };
      }
    }
  }, {
    key: "addKindMetadata",
    value: function addKindMetadata(kind, _ref10) {
      var _this$_kinds$kind$dec;

      var parameters = _ref10.parameters,
          decorators = _ref10.decorators;
      this.ensureKind(kind);

      if (parameters) {
        checkGlobalArgs(parameters);
        checkStorySort(parameters);
      }

      this._kinds[kind].parameters = (0, _parameters.combineParameters)(this._kinds[kind].parameters, parameters);

      (_this$_kinds$kind$dec = this._kinds[kind].decorators).push.apply(_this$_kinds$kind$dec, _toConsumableArray(decorators));
    }
  }, {
    key: "addArgTypesEnhancer",
    value: function addArgTypesEnhancer(argTypesEnhancer) {
      if (Object.keys(this._stories).length > 0) throw new Error('Cannot add a parameter enhancer to the store after a story has been added.');

      this._argTypesEnhancers.push(argTypesEnhancer);
    } // Combine the global, kind & story parameters of a story

  }, {
    key: "combineStoryParameters",
    value: function combineStoryParameters(parameters, kind) {
      return (0, _parameters.combineParameters)(this._globalMetadata.parameters, this._kinds[kind].parameters, parameters);
    }
  }, {
    key: "addStory",
    value: function addStory(_ref11, _ref12) {
      var _this3 = this;

      var id = _ref11.id,
          kind = _ref11.kind,
          name = _ref11.name,
          original = _ref11.storyFn,
          _ref11$parameters = _ref11.parameters,
          storyParameters = _ref11$parameters === void 0 ? {} : _ref11$parameters,
          _ref11$decorators = _ref11.decorators,
          storyDecorators = _ref11$decorators === void 0 ? [] : _ref11$decorators;
      var applyDecorators = _ref12.applyDecorators,
          _ref12$allowUnsafe = _ref12.allowUnsafe,
          allowUnsafe = _ref12$allowUnsafe === void 0 ? false : _ref12$allowUnsafe;
      if (!this._configuring && !allowUnsafe) throw new Error('Cannot add a story when not configuring, see https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#story-store-immutable-outside-of-configuration');

      if (storyParameters) {
        checkGlobalArgs(storyParameters);
        checkStorySort(storyParameters);
      }

      var _stories = this._stories;

      if (_stories[id]) {
        _clientLogger.logger.warn((0, _tsDedent["default"])(_templateObject(), id));
      }

      var identification = {
        id: id,
        kind: kind,
        name: name,
        story: name // legacy

      }; // immutable original storyFn

      var getOriginal = function getOriginal() {
        return original;
      };

      this.ensureKind(kind);
      var kindMetadata = this._kinds[kind];
      var decorators = [].concat(_toConsumableArray(storyDecorators), _toConsumableArray(kindMetadata.decorators), _toConsumableArray(this._globalMetadata.decorators));

      var finalStoryFn = function finalStoryFn(context) {
        var passArgsFirst = context.parameters.passArgsFirst;
        return passArgsFirst || typeof passArgsFirst === 'undefined' ? original(context.args, context) : original(context);
      }; // lazily decorate the story when it's loaded


      var getDecorated = (0, _memoizerific["default"])(1)(function () {
        return applyDecorators(finalStoryFn, decorators);
      });
      var hooks = new _hooks.HooksContext(); // We need the combined parameters now in order to calculate argTypes, but we won't keep them

      var combinedParameters = this.combineStoryParameters(storyParameters, kind);

      var _this$_argTypesEnhanc = this._argTypesEnhancers.reduce(function (accumlatedParameters, enhancer) {
        return Object.assign(Object.assign({}, accumlatedParameters), {}, {
          argTypes: enhancer(Object.assign(Object.assign({}, identification), {}, {
            storyFn: original,
            parameters: accumlatedParameters,
            args: {},
            globalArgs: {}
          }))
        });
      }, combinedParameters),
          _this$_argTypesEnhanc2 = _this$_argTypesEnhanc.argTypes,
          argTypes = _this$_argTypesEnhanc2 === void 0 ? {} : _this$_argTypesEnhanc2;

      var storyParametersWithArgTypes = Object.assign(Object.assign({}, storyParameters), {}, {
        argTypes: argTypes
      });

      var storyFn = function storyFn(runtimeContext) {
        return getDecorated()(Object.assign(Object.assign(Object.assign({}, identification), runtimeContext), {}, {
          // Calculate "combined" parameters at render time (NOTE: for perf we could just use combinedParameters from above?)
          parameters: _this3.combineStoryParameters(storyParametersWithArgTypes, kind),
          hooks: hooks,
          args: _stories[id].args,
          globalArgs: _this3._globalArgs
        }));
      }; // Pull out parameters.args.$ || .argTypes.$.defaultValue into initialArgs


      var initialArgs = combinedParameters.args;
      var defaultArgs = Object.entries(argTypes).reduce(function (acc, _ref13) {
        var _ref14 = _slicedToArray(_ref13, 2),
            arg = _ref14[0],
            defaultValue = _ref14[1].defaultValue;

        if (defaultValue) acc[arg] = defaultValue;
        return acc;
      }, {});
      _stories[id] = Object.assign(Object.assign({}, identification), {}, {
        hooks: hooks,
        getDecorated: getDecorated,
        getOriginal: getOriginal,
        storyFn: storyFn,
        parameters: Object.assign(Object.assign({}, storyParameters), {}, {
          argTypes: argTypes
        }),
        args: Object.assign(Object.assign({}, defaultArgs), initialArgs)
      });
    }
  }, {
    key: "removeStoryKind",
    value: function removeStoryKind(kind) {
      var _ref15 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref15$allowUnsafe = _ref15.allowUnsafe,
          allowUnsafe = _ref15$allowUnsafe === void 0 ? false : _ref15$allowUnsafe;

      if (!this._configuring && !allowUnsafe) throw new Error('Cannot remove a kind when not configuring, see https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#story-store-immutable-outside-of-configuration');
      if (!this._kinds[kind]) return;
      this._kinds[kind].parameters = {};
      this._kinds[kind].decorators = [];
      this.cleanHooksForKind(kind);
      this._stories = Object.entries(this._stories).reduce(function (acc, _ref16) {
        var _ref17 = _slicedToArray(_ref16, 2),
            id = _ref17[0],
            story = _ref17[1];

        if (story.kind !== kind) acc[id] = story;
        return acc;
      }, {});
    }
  }, {
    key: "updateGlobalArgs",
    value: function updateGlobalArgs(newGlobalArgs) {
      this._globalArgs = Object.assign(Object.assign({}, this._globalArgs), newGlobalArgs);

      this._channel.emit(_coreEvents["default"].GLOBAL_ARGS_UPDATED, this._globalArgs);
    }
  }, {
    key: "updateStoryArgs",
    value: function updateStoryArgs(id, newArgs) {
      if (!this._stories[id]) throw new Error("No story for id ".concat(id));
      var args = this._stories[id].args;
      this._stories[id].args = Object.assign(Object.assign({}, args), newArgs);

      this._channel.emit(_coreEvents["default"].STORY_ARGS_UPDATED, id, this._stories[id].args);
    }
  }, {
    key: "raw",
    value: function raw(options) {
      var _this4 = this;

      return Object.values(this._stories).filter(function (i) {
        return !!i.getDecorated;
      }).filter(function (i) {
        return includeStory(i, options);
      }).map(function (i) {
        return _this4.mergeAdditionalDataToStory(i);
      });
    }
  }, {
    key: "extract",
    value: function extract() {
      var _this$_globalMetadata3,
          _this$_globalMetadata4,
          _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var stories = Object.entries(this._stories);
      var storySortParameter = (_this$_globalMetadata3 = this._globalMetadata.parameters) === null || _this$_globalMetadata3 === void 0 ? void 0 : (_this$_globalMetadata4 = _this$_globalMetadata3.options) === null || _this$_globalMetadata4 === void 0 ? void 0 : _this$_globalMetadata4.storySort;

      if (storySortParameter) {
        var sortFn;

        if (typeof storySortParameter === 'function') {
          sortFn = storySortParameter;
        } else {
          sortFn = (0, _storySort["default"])(storySortParameter);
        }

        _stable["default"].inplace(stories, sortFn);
      } else {
        // NOTE: when kinds are HMR'ed they get temporarily removed from the `_stories` array
        // and thus lose order. However `_kindOrder` preservers the original load order
        _stable["default"].inplace(stories, function (s1, s2) {
          return _this5._kinds[s1[1].kind].order - _this5._kinds[s2[1].kind].order;
        });
      } // removes function values from all stories so they are safe to transport over the channel


      return stories.reduce(function (acc, _ref18) {
        var _ref19 = _slicedToArray(_ref18, 2),
            id = _ref19[0],
            story = _ref19[1];

        if (!includeStory(story, options)) return acc;
        var extracted = toExtracted(story);
        if (options.normalizeParameters) return Object.assign(acc, _defineProperty({}, id, extracted));
        var _ref20 = extracted,
            parameters = _ref20.parameters,
            kind = _ref20.kind;
        return Object.assign(acc, _defineProperty({}, id, Object.assign(extracted, {
          parameters: _this5.combineStoryParameters(parameters, kind)
        })));
      }, {});
    }
  }, {
    key: "clearError",
    value: function clearError() {
      this._error = null;
    }
  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      this._selection = selection;

      if (this._channel) {
        this._channel.emit(_coreEvents["default"].CURRENT_STORY_WAS_SET, this._selection); // If the selection is set while configuration is in process, we are guaranteed
        // we'll emit RENDER_CURRENT_STORY at the end of the process, so we shouldn't do it now.


        if (!this._configuring) {
          this._channel.emit(_coreEvents["default"].RENDER_CURRENT_STORY);
        }
      }
    }
  }, {
    key: "getStoryKinds",
    value: function getStoryKinds() {
      return Array.from(new Set(this.raw().map(function (s) {
        return s.kind;
      })));
    }
  }, {
    key: "getStoriesForKind",
    value: function getStoriesForKind(kind) {
      return this.raw().filter(function (story) {
        return story.kind === kind;
      });
    }
  }, {
    key: "getRawStory",
    value: function getRawStory(kind, name) {
      return this.getStoriesForKind(kind).find(function (s) {
        return s.name === name;
      });
    }
  }, {
    key: "cleanHooks",
    value: function cleanHooks(id) {
      if (this._stories[id]) {
        this._stories[id].hooks.clean();
      }
    }
  }, {
    key: "cleanHooksForKind",
    value: function cleanHooksForKind(kind) {
      var _this6 = this;

      this.getStoriesForKind(kind).map(function (story) {
        return _this6.cleanHooks(story.id);
      });
    } // This API is a reimplementation of Storybook's original getStorybook() API.
    // As such it may not behave *exactly* the same, but aims to. Some notes:
    //  - It is *NOT* sorted by the user's sort function, but remains sorted in "insertion order"
    //  - It does not include docs-only stories

  }, {
    key: "getStorybook",
    value: function getStorybook() {
      var _this7 = this;

      return Object.values(this.raw().reduce(function (kinds, story) {
        if (!includeStory(story)) return kinds;
        var kind = story.kind,
            name = story.name,
            storyFn = story.storyFn,
            fileName = story.parameters.fileName; // eslint-disable-next-line no-param-reassign

        if (!kinds[kind]) kinds[kind] = {
          kind: kind,
          fileName: fileName,
          stories: []
        };
        kinds[kind].stories.push({
          name: name,
          render: storyFn
        });
        return kinds;
      }, {})).sort(function (s1, s2) {
        return _this7._kinds[s1.kind].order - _this7._kinds[s2.kind].order;
      });
    }
  }, {
    key: "mergeAdditionalDataToStory",
    value: function mergeAdditionalDataToStory(story) {
      return Object.assign(Object.assign({}, story), {}, {
        parameters: this.combineStoryParameters(story.parameters, story.kind),
        globalArgs: this._globalArgs
      });
    }
  }]);

  return StoryStore;
}();

exports["default"] = StoryStore;