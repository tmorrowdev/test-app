"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const find_module_1 = require("@schematics/angular/utility/find-module");
const path_helper_1 = require("../shared/path-helper");
const log_helper_1 = require("../shared/log-helper");
function updateImportPaths(filePath) {
    return (tree) => {
        let modifications = getImportPathModifications(tree, filePath);
        let source = tree.read(filePath).toString();
        for (let modification of modifications.reverse()) {
            source =
                source.slice(0, modification.startPosition) +
                    modification.content +
                    source.slice(modification.endPosition);
        }
        tree.overwrite(filePath, source);
        return tree;
    };
}
exports.updateImportPaths = updateImportPaths;
function getImportPathModifications(tree, filePath) {
    const sourceCode = tree.read(filePath).toString();
    const rootNode = ts.createSourceFile(filePath, sourceCode, ts.ScriptTarget.Latest, true);
    const modifications = [];
    const modulePathFileBelongsTo = find_module_1.findModule(tree, path_helper_1.getFolderPath(filePath));
    function updatePaths(node) {
        if (ts.isImportDeclaration(node)) {
            const importSegments = node.getChildren();
            const importNode = importSegments.find(segment => segment.kind === ts.SyntaxKind.StringLiteral);
            if (importNode &&
                !isThirdPartyLibImport(importNode) &&
                importsForeignModuleCode(importNode, modulePathFileBelongsTo, filePath, tree)) {
                const moduleFromImportPath = getModulePathFromImport(importNode.getText(), filePath, tree);
                modifications.push({
                    startPosition: importNode.pos + 1,
                    endPosition: importNode.end + 1,
                    content: `'${path_helper_1.convertModulePathToPublicAPIImport(moduleFromImportPath)}';`
                });
            }
        }
    }
    rootNode.forEachChild(updatePaths);
    return modifications;
}
function isThirdPartyLibImport(importNode) {
    return !importNode.getText().startsWith(`'.`);
}
function importsForeignModuleCode(importNode, modulePathFileBelongsToPath, filePath, tree) {
    const importStringLiteral = importNode.getText();
    return (modulePathFileBelongsToPath !== getModulePathFromImport(importStringLiteral, filePath, tree));
}
function getModulePathFromImport(importLiteral, filePath, tree) {
    try {
        return find_module_1.findModule(tree, path_helper_1.convertToAbsolutPath(filePath, importLiteral));
    }
    catch (e) {
        log_helper_1.logError(`Could not find a module for the import path ${importLiteral} in ${filePath}. 
    Please adjust the import path and rerun the schematics`);
        process.exit();
    }
}
//# sourceMappingURL=update-import-paths.rule.js.map