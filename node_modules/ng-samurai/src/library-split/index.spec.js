"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const testing_1 = require("@angular-devkit/schematics/testing");
const workspaceOptions = {
    name: 'some-workspace',
    newProjectRoot: 'projects',
    version: '8.0.0'
};
const libOptions = {
    name: 'some-lib'
};
const collectionPath = path.join(__dirname, '../collection.json');
const runner = new testing_1.SchematicTestRunner('schematics', collectionPath);
let appTree;
describe('split', () => {
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        console.log = () => { };
        appTree = yield runner
            .runExternalSchematicAsync('@schematics/angular', 'workspace', workspaceOptions)
            .toPromise();
        appTree = yield runner
            .runExternalSchematicAsync('@schematics/angular', 'library', libOptions, appTree)
            .toPromise();
        removeDefaultLibraryModule();
        yield generateModuleAndComponent('foo');
        const fooServiceOptions = {
            name: 'foo',
            project: 'some-lib',
            path: 'projects/some-lib/src/lib/foo'
        };
        appTree = yield runner
            .runExternalSchematicAsync('@schematics/angular', 'service', fooServiceOptions, appTree)
            .toPromise();
        yield generateModuleAndComponent('bar');
        const fooComponentOptions = {
            name: 'baz',
            path: 'projects/some-lib/src/lib/bar',
            module: 'bar',
            project: 'some-lib'
        };
        appTree = yield runner
            .runExternalSchematicAsync('@schematics/angular', 'component', fooComponentOptions, appTree)
            .toPromise();
        appTree.create('projects/some-lib/src/lib/bar/bar.model.ts', `
      export interface Bar {
        foo: string;
        baz: string;
      }
    `);
    }));
    function generateModuleAndComponent(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const fooModuleOptions = { name, project: 'some-lib' };
            appTree = yield runner
                .runExternalSchematicAsync('@schematics/angular', 'module', fooModuleOptions, appTree)
                .toPromise();
            const fooComponentOptions = {
                name,
                module: 'foo',
                project: 'some-lib'
            };
            appTree = yield runner
                .runExternalSchematicAsync('@schematics/angular', 'component', fooComponentOptions, appTree)
                .toPromise();
        });
    }
    function removeDefaultLibraryModule() {
        appTree.delete('/projects/some-lib/src/lib/some-lib.module.ts');
        appTree.delete('/projects/some-lib/src/lib/some-lib.component.spec.ts');
        appTree.delete('/projects/some-lib/src/lib/some-lib.component.ts');
        appTree.delete('/projects/some-lib/src/lib/some-lib.service.ts');
        appTree.delete('/projects/some-lib/src/lib/some-lib.service.spec.ts');
    }
    describe('public-api', () => {
        describe('public-api top level', () => {
            function expectedPublicAPIContent(fileNames) {
                let result = '';
                fileNames.forEach((fileName) => {
                    result += `export * from '${fileName}';\n`;
                });
                return result;
            }
            it('should export foo and bar from the public-api', () => __awaiter(void 0, void 0, void 0, function* () {
                const updatedTree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
                const topLevelPublicAPIContent = updatedTree.readContent('/projects/some-lib/src/public-api.ts');
                const expectedTopLevelPublicAPIContent = expectedPublicAPIContent([
                    'some-lib/src/lib/foo',
                    'some-lib/src/lib/bar'
                ]);
                expect(topLevelPublicAPIContent).toEqual(expectedTopLevelPublicAPIContent);
            }));
        });
        describe('public_api subentry', () => {
            function expectedSubentryPublicAPIContent(fileNames) {
                let result = '';
                fileNames.forEach((fileName) => {
                    result += `export * from './${fileName}';\n`;
                });
                return result;
            }
            it('should add a public_api to foo module', () => __awaiter(void 0, void 0, void 0, function* () {
                const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
                expect(tree.exists('/projects/some-lib/src/lib/foo/public-api.ts')).toBe(true);
            }));
            it('should add a public_api to bar module', () => __awaiter(void 0, void 0, void 0, function* () {
                const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
                expect(tree.exists('/projects/some-lib/src/lib/bar/public-api.ts')).toBe(true);
            }));
            it('should not add a public_api to baz module', () => __awaiter(void 0, void 0, void 0, function* () {
                const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
                expect(tree.exists('/projects/some-lib/src/lib/bar/baz/public-api.ts')).not.toBe(true);
            }));
            it('should export foo.component.ts and foo.module.ts from foos public-api', () => __awaiter(void 0, void 0, void 0, function* () {
                const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
                const publicAPI = tree.read('/projects/some-lib/src/lib/foo/public-api.ts').toString();
                const expectedFilesIncludedInPublicAPI = ['foo.module', 'foo.component', 'foo.service'];
                const expectedFileContent = expectedSubentryPublicAPIContent(expectedFilesIncludedInPublicAPI);
                expect(publicAPI).toEqual(expectedFileContent);
            }));
            it('should export bar.component.ts, bar.module.ts, bar.model and baz.component.ts from bars public-api', () => __awaiter(void 0, void 0, void 0, function* () {
                const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
                const publicAPI = tree.read('/projects/some-lib/src/lib/bar/public-api.ts').toString();
                const expectedFilesIncludedInPublicAPI = [
                    'bar.module',
                    'bar.component',
                    'bar.model',
                    'baz/baz.component'
                ];
                const expectedFileContent = expectedSubentryPublicAPIContent(expectedFilesIncludedInPublicAPI);
                expect(publicAPI).toEqual(expectedFileContent);
            }));
        });
    });
    describe('index.ts', () => {
        it('should add an index.ts to foo module', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            expect(tree.exists('/projects/some-lib/src/lib/foo/index.ts')).toBe(true);
        }));
        it('should add export everything from public-api inside the index.ts of foo', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            expect(tree.read('/projects/some-lib/src/lib/foo/index.ts').toString()).toEqual("export * from './public-api';\n");
        }));
        it('should add an index.ts bar module', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            expect(tree.exists('/projects/some-lib/src/lib/bar/index.ts')).toBe(true);
        }));
        it('should add export everything from public-api inside the index.ts of bar', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            expect(tree.read('/projects/some-lib/src/lib/bar/index.ts').toString()).toEqual("export * from './public-api';\n");
        }));
        it('should not add an index.ts to baz module', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            expect(tree.exists('/projects/some-lib/src/lib/bar/baz/index.ts')).not.toBe(true);
        }));
    });
    describe('package.json', () => {
        it('should add an index.ts to foo module', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            expect(tree.exists('/projects/some-lib/src/lib/foo/package.json')).toBe(true);
        }));
        it('should add the correct config to the package.json of foo subentry', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            const expectedSubentryConfig = {
                ngPackage: {
                    lib: {
                        entryFile: 'public-api.ts',
                        cssUrl: 'inline'
                    }
                }
            };
            const subEntryConfig = JSON.parse(tree.read('/projects/some-lib/src/lib/foo/package.json').toString());
            expect(subEntryConfig).toEqual(expectedSubentryConfig);
        }));
        it('should add an packag.json to bar module', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            expect(tree.exists('/projects/some-lib/src/lib/bar/package.json')).toBe(true);
        }));
        it('should add the correct config to the package.json of bar subentry', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            const expectedSubentryConfig = {
                ngPackage: {
                    lib: {
                        entryFile: 'public-api.ts',
                        cssUrl: 'inline'
                    }
                }
            };
            const subEntryConfig = JSON.parse(tree.read('/projects/some-lib/src/lib/bar/package.json').toString());
            expect(subEntryConfig).toEqual(expectedSubentryConfig);
        }));
        it('should not add a package.json to baz module', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            expect(tree.exists('/projects/some-lib/src/lib/bar/baz/package.json')).not.toBe(true);
        }));
    });
    describe('paths', () => {
        function updateBarModuleContent() {
            const barModuleFilePath = '/projects/some-lib/src/lib/bar/bar.module.ts';
            const importStatementToAdd = `import {FooModule} from '../foo/foo.module.ts';`;
            const barModuleFileContent = appTree.readContent(barModuleFilePath);
            appTree.overwrite(barModuleFilePath, `${importStatementToAdd}\n${barModuleFileContent}`);
        }
        function getExpectedBarModuleContent() {
            const barModuleFilePath = '/projects/some-lib/src/lib/bar/bar.module.ts';
            const expectedChangedImportPath = `import {FooModule} from 'some-lib/src/lib/foo';`;
            const barModuleFileContent = appTree.readContent(barModuleFilePath);
            return `${expectedChangedImportPath}\n${barModuleFileContent}`;
        }
        function updateBazComponentContent() {
            const bazComponentFilePath = '/projects/some-lib/src/lib/bar/baz/baz.component.ts';
            const importStatementToAdd = `import {BarModel} from '../bar/bar.model.ts';`;
            const bazComponentFileContent = appTree.readContent(bazComponentFilePath);
            appTree.overwrite(bazComponentFilePath, `${importStatementToAdd}\n${bazComponentFileContent}`);
        }
        function getExpectedBazComponentContent() {
            const bazComponentFilePath = '/projects/some-lib/src/lib/bar/baz/baz.component.ts';
            const importStatementToAdd = `import {BarModel} from '../bar/bar.model.ts';`;
            const bazComponentFileContent = appTree.readContent(bazComponentFilePath);
            return `${importStatementToAdd}\n${bazComponentFileContent}`;
        }
        it(`should adjust the paths to other modules but not the third pary imports and not the imports from 
      the same folder`, () => __awaiter(void 0, void 0, void 0, function* () {
            // needs to be called before we update the module file content
            const expectedModuleContent = getExpectedBarModuleContent();
            updateBarModuleContent();
            const updatedTree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            const moduleContentAfterSchematics = updatedTree.readContent('/projects/some-lib/src/lib/bar/bar.module.ts');
            expect(moduleContentAfterSchematics).toEqual(expectedModuleContent);
        }));
        it('should not update the baz components content since the import paths do not need to be updated', () => __awaiter(void 0, void 0, void 0, function* () {
            // needs to be called before we update the module file content
            const expectedComponentContent = getExpectedBazComponentContent();
            updateBazComponentContent();
            const updatedTree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            const componentContentAfterSchematics = updatedTree.readContent('/projects/some-lib/src/lib/bar/baz/baz.component.ts');
            expect(componentContentAfterSchematics).toEqual(expectedComponentContent);
        }));
    });
    describe('tsconfig', () => {
        function deletePathsFromTsconfig() {
            const tsconfigContent = JSON.parse(appTree.readContent('tsconfig.json'));
            delete tsconfigContent.compilerOptions.paths;
            appTree.overwrite('tsconfig.json', JSON.stringify(tsconfigContent));
        }
        it('should update the paths in the tsconfig.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const updatedTree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            const tsconfigContent = JSON.parse(updatedTree.readContent('tsconfig.json'));
            const expectedPaths = {
                'some-lib': ['dist/some-lib/some-lib', 'dist/some-lib'],
                'some-lib/*': ['projects/some-lib/*', 'projects/some-lib']
            };
            const paths = tsconfigContent.compilerOptions.paths;
            expect(paths).toEqual(expectedPaths);
        }));
        it('should add paths to the tsconfig.json even if no path exist', () => __awaiter(void 0, void 0, void 0, function* () {
            deletePathsFromTsconfig();
            const updatedTree = yield runner.runSchematicAsync('split-lib', {}, appTree).toPromise();
            const tsconfigContent = JSON.parse(updatedTree.readContent('tsconfig.json'));
            const expectedPaths = {
                'some-lib/*': ['projects/some-lib/*', 'projects/some-lib']
            };
            const paths = tsconfigContent.compilerOptions.paths;
            expect(paths).toEqual(expectedPaths);
        }));
    });
});
//# sourceMappingURL=index.spec.js.map